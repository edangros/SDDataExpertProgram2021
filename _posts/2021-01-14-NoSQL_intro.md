---
layout: post
title: "NoSQL"
date: 2021-01-07 20:05:18 UTC+9
comments: true
---


# NoSQL

## NoSQL 개론
NoSQL은 이름만 들으면 "SQL을 쓰지 않는"으로 여겨지나, 일종의 언어유희이며 실재로는 "Not only SQL", 즉 SQL'만'을 쓰지 않고 다른 종류의 데이터 기법을 사용하여 SQL이 가지는 단점을 극복하기 위한 데이터베이스 시스템이다.

오해해서는 안되는 것이, 현 시점에서 NoSQL은 크게 그 지분을 넓히고 있지만, 실재로는 많은 데이터베이스가 SQL을 사용할 수 있는 관계형 DB에 기반하고 있으며, NoSQL이 빅데이터 처리에 강하다고 하지만 그 결과데이터를 관계형 DB에 삽입하는 사례 또한 많다. SQL 또한 노드 구성에 따라 분산형 처리가 가능하며 구조적 유연성을 가질 수 있다. 우리가 다루게 될 데이터 중 csv로 저장 가능한 데이터는 거의 항상 SQL DB구조가 유리하고, 간단하며, 사례가 누적되어 있다. 따라서, 데이터베이스를 다룸에 있어서 관계형 DB와 SQL은 피할 수 없고, 익혀야만 하는 데이터이다.

그럼에도 NoSQL이 현 시점에서 지분을 크게 넓히는 데에는, 다음과 같은 이점들이 크게 작용하고 있다.
 - 유연성 : 일반적으로 NoSQL은 구성요소가 엄격할 것을 요구하지 않는다. 같은 필드에 다른 형태의 자료형을 받을 수도 있고, 같은 테이블(또는 그것과 비슷한 것들) 내에 있는 구성요소들이 서로 다른 필드를 가질 수도 있다. 관계형 DB에서 이러한 형태는 데이터베이스의 용량을 낭비하고 쿼리 성능도 낮추므로 선택하기 힘들다.
 - 고성능 : NoSQL은 자신이 주로 해내는 데이터 구조에 최적화된 검색 및 처리 성능을 가지고 있다. 이러한 경우에서는 관계형 DB보다 더 뛰어난 성능을 보여주는 경우도 많다.
 - 고기능성 : NoSQL 데이터베이스는 자신의 데이터 모델에 맞추어 기존의 관계헝 SQL이 제공하지 못하는 새로운 API와 데이터 유형을 제공해줄 수 있다. 기존의 SQL에서 각 테이블의 JOIN연산 등으로 성능부하를 심하게 주고 비직관적으로 해결해야 할 내용들을 더 직관적으로 해소할 수 있게 해준다.
 - 확장성 : 관계형 DB 또한 시대의 흐름에 맞추어 병렬 확장이 가능해지고 분산저장과 복제 등을 지원하고 있지만, 이 분야에서 더 먼저 맞추어나간 건 NoSQL DB들이다. 병렬 확장과 각 노드의 관리는 대부분의 NoSQL에서 상상하는 것보다 간단하게 이루어지고, 안정성 또한 뛰어나다.

 이중에서 고성능과 고기능성은 선뜻 이해되지 않을 수 있다. 테이블을 조회하는 것보다 비정형인 문서 뭉텅이를 조회하는 것이 이론상 더 빠를 수 있는가? 테이블을 조작하는 것보다 구성 내용물조차 정확하지 않은 필드들을 조작하는데에 더 뛰어난 기능들을 제공할 수 있는가?

 **그렇다**

## NoSQL vs 관계형 DB 예시 : 게임에서 '인벤토리'의 구현

SQL 데이터베이스를 배우면서 제대로 따라왔다면, 문득 그런 의문이 들 수 밖에 없다. SQL DB에서 하나의 필드에는 하나의 값만이 들어갈 수 있으며 그 형식마저 제한되어 있다. 테이블 안에 새로운 배열을 넣는 등, 길이를 가변 상태로 만드는 것은, 엄격한 관계형 데이터베이스에서는 매우 복잡한 문제가 된다. 이는 새로운 테이블을 만들고 JOIN 연산을 사용하는 것으로 해결된다.

게임에서의 '인벤토리'를 생각해보자. 인벤토리는 아래와 같은 정보가 필요할 것이다.

- 인벤토리는 플레이어가 존재해야 한다. 따라서 '플레이어'에 종속적이다.
- 인벤토리는 플레이어가 소유한 '아이템'에도 종속적이다.
- 플레이어는 여러 종류의 아이템을 소유할 수 있다.
- 플레이어는 여러 종류의 아이템을 각기 여러개 소유할 수 있다.
- 게임 운영 도중 플레이어는 점점 늘어난다.
- 게임 운영 도중 아이템 또한 점점 늘어난다.
- 기간제 아이템, 버그로 지급된 아이템 등에 대한 관리자 조치를 위해, 아이템은 빠르게 쿼리되고 삭제/생성이 용이해야 한다.

처음 두 조건은, 관계형 데이터베이스 설계 단계에서 이미 '플레이어'와 '아이템'의 두 직관적인 데이터베이스 외에 '플레이어의 아이템 소유목록'이라는 새로운 테이블이 만들어져야 한다는 걸 암시한다. 관계형 DB에서도 각종 편법을 통해 어떻게든 이 문제를 회피할 수 있겠지만, 이미 시작부터 비직관적인 상태가 되어버렸다는 건 어쩔 수 없다. 하지만 아직 문제는 끝나지 않았다.

```
- 테이블 \[플레이어의 아이템 소유목록\]
   - 플레이어 id
   - 아이탬 id
   - 소유량
```
위 테이블을 결국엔 만든 상태이다. 그런데, 이 온라인 게임이 뜻밖에도 아주 성공해버렸고, 유저는 수만명에 이르고 있으며, 게임 내 아이탬 숫자만 수천개에 달하고 있다고 생각하자. 거기에 '인벤토리 확장 아이탬'을 새로 판매하기 시작하여 플레이어별로 여러 개의 인벤토리를 가지기까지 하고 있다. 현 상태에서 테이블은
```
- 테이블 \[플레이어의 아이템 소유목록\]
   - 플레이어 id (수만개)
   - 아이템 id (수천개)
   - 플레이어 인벤토리 번호 (끽해야 10개)
   - 소유량
```
이 테이블의 기본키(primary key)는 무엇인가? 어쩔 수 없다. (플레이어 id, 아이템 id, 플레이어 인벤토리 번호)까지가 기본키이다. 검색하려면 저 3가지 모두가 정의되어야 한다. 거기에, 이 테이블의 필드 갯수는

```
 수만(플레이어) \* 수천 (아이탬) = **수천만(!!!!)**
```

개에 이르게 된다.

그래도 아직까진 적절한 업스케일링과 인덱싱을 통해 버텨볼 수 있을 것이다. 하지만 관리에 있어서마저도 관계형 DB의 한계가 나타나고 만다.

>게임 운영 도중 기간제 아이템 10종류를 만들었다. 2021년 2월 1일, 이 id를 가진 모든 아이템은 플레이어 인벤토리에서 삭제되어야 한다. 이 때, 이 기간제 아이템을 보유한 플레이어들에겐 보상으로 개당 게임 내 재화 100골드를 지급한다. 게임 내 재화 보유량은 플레이어 테이블에 저장되어 있다.

위 문제 해결을 위한 관계형 DB의 SQL을 생각해보자. 우선적으로, 아이탬 id에 해당하는 테이블을 추출해야 한다. 삭제해야 할 아이템 id로 테이블을 만든 뒤, JOIN을 통해 해결하면 될 것이다. **수천만개의 줄을**. 그 다음, JOIN되어 얻은 데이터 목록을 이용하여 플레이어 테이블에 접근해, 플레이어들의 게임 내 재화 획득량을 조절하면 된다. **수만개의 줄과 조인시켜서**. 언뜻 보아도, 그렇게 쉽게 이루어질 작업은 아니다. 쿼리가 도는 동안 플레이어 사이에 아이템을 주고받는 등의 예외상황이 발생할 수 있음을 생각한다면 필연적으로 서버 점검이 이루어지게 될 것이고, 서비스가 잠시 중단될 것이다.

도큐먼트형 DB인 MongoDB에서 위 데이터를 어떻게 처리할 수 있는지 보자.
>- MongoDB는 각 플레이어를 '도큐먼트'로 저장한다. 이 도큐먼트 목록의 기본키는 플레이어 id이다. 아이템 또한 아이템id를 통한 도큐먼트 목록으로 저장된다.
>- MongoDB의 도큐먼트 내부는 key=value 형태로 구성되어 있으며, 각 플레이어는
>>```
>>{  
>>     _id: xx,
>>     cash: xx,
>>     inventory:
>>     [
>>      {itemid: xxx, amount: xxx},
>>      {itemid: xxx, amount: xxx},
>>      {itemid: xxx, amount: xxx},
>>      {itemid: xxx, amount: xxx},
>>     ]
>>}
>>```
>>형태의 문서를 가진다

제 3의 테이블이 없다! 유저 수와 아이템 수가 늘어나면서 발생하는 기하급수적인 필드 증가도 없다. 거기에 **link**와 **embed**로 플레이어와 아이템 사이의 1:N, N:M관계를 **부가적인 테이블 없이** 직관적으로 구현할 수 있다.

MongoDB는 도큐먼트 내부 키값 기준의 쿼리를 빠르게 할 수 있으며, JOIN과 같은 복잡한 연산 없이, 존재하는 테이블만으로 빠르게 쿼리를 돌릴 수 있다. 글의 길이가 위의 관계형 DB에 비해 매우 짧은데, **실재로 이정도로 구축부터 관리 절차가 간단해진다.**

MongoDB는 NoSQL DB 중 도큐먼트 DB의 일종이며, 이외에도 NoSQL DB는 다양한 패러다임에 의한 다양한 솔루션이 제공되어있다. SQL과는 달리 서로가 추구하는 바가 명백히 다르므로, ***각 데이터베이스 솔루션이 추구하는 방향***과 ***취급하는 데이터의 형태***를 이해하는 것이 NoSQL DB를 사용하는 시작이라 할 수 있을 것이다.

따라서 NoSQL을 조사함에 있어서 각 DB 시스템의 아래 3가지를 중점적으로 보아야 한다.

 - 해당 DBMS가 추구하는 방향 (=강점)
 - 해당 DBMS가 취급하는 데이터의 형식
 - 해당 DBMS가 쿼리를 돌리는 방식


위의 MongoDB는 본 문서에서 그 결과를 알 수 있을 것이다

**MongoDB**
 - **강점** : Join을 사용하지 않는다. 직관적이다. 스키마가 없다. 기본키를 제공해서 빠른 쿼리가 가능하다. 문서로 데이터를 다루므로 추가/편집이 용이하다.
 - **데이터의 형식** : JSON형태의 '문서'(Document)
 - **쿼리를 돌리는 방식** : 문서에 최적화된 쿼리(Document Query)