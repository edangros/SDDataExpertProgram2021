SOLID principles
<<<책보고 공부중... 아직 틀리거나 부족한 내용이 있을수 있습니다>>>
어느정도 클래스가 뭔지 감이 잡히셨다면 Head first design patterns(헤드 퍼스트 디자인 패턴, 한빛미디어) 책을 한번 읽는걸 추천드립니다.
내부에 SOLID원칙 설명도 있고 어떤 식으로 현업에 적용되는지도 매우 가볍게 설명되어있어서 읽기 편해요
책 무게는 그렇게 가볍지 않지만 컴퓨터 앞에 앉아서 자습하기 귀찮을 때 이불 속에 파묻혀서 읽기에도 괜찮은 책입니다.
(저는 연구실에서 실험은 안되는데 앉아서 시간은 때워야 할 때 교수님 몰래 읽었습니다)
SOLID 원칙은 해당 책 내용은 아니고, 객체지향 관련한 나이 지긋하신 분들이 정리한 객체지향 프로그래밍에서 지켜야 할 원칙입니다.
다 정리하고 보니 '캡슐화'라는 단어의 아주 긴 설명이라는 생각이 드네요


S : Single Responsibility Principle(단일 책임 원칙)    *****제일 중요!!!!!! 이게 지켜지지 않으면 다른 원칙은 지킬수도 없음
모든 클래스는 한 가지 책임만 져야 한다
->한 가지 클래스가 두 가지 이상의 기능을 지녀서도 안된다 + 어떠한 한 가지 기능이 여러 클래스에 쪼개져 있으면 안된다

-모든 무기와 관련된 사항은 Weapon 클래스가 해결해야 한다.
--Weapon 클래스가 무기와 함께 무기를 쥐고 있는 캐릭터까지 통제해서는 안된다. 캐릭터는 Character 클래스가 모든 전권을 쥐어야 한다.
--Weapon 클래스가 Weapon_base, Weapon_Swing 등으로 쪼개져있고, 이 개체들이 서로에게 밀접히 관련되어 따로 존재하지 못한다면 안된다.

-이게 이루어지지 않았다면 '객체 지향'이라 할 수 없다.

<상속과 S원칙>
'모든 공통된 부분'은 부모가 가져야 한다. (공통된 부분은 부모 클래스가 책임진다)
'모든 다른 부분'은 각 자식 개체가 가져야 한다 (각 개체 별도의 구현은 각 자식 개체가 책임진다)
-다시 말해 부모 클래스는 자신은 사용하지 않는 부분을 특정 자식 클래스가 가진다고 포함해서는 안된다.
 ('모든 자식 클래스'가 가진다면 부모 클래스가 포함하고 있어야 한다)  -> 아래의 I원칙과 관련
-또한 자식 클래스는 공통된 부분들을 각자 포함해서는 안된다

ex)조류 클래스 아래에 팽귄과 독수리가 있다면
- 두 새의 공통점인 날개, 다리, 머리,눈 등은 모두 '조류' 클래스가 가지고 있어야 한다.
- '색상', '깃털모양' 등 두 클래스에서 구현 자체는 다르나 공통된 부분은 조류 클래스에서 선언하고 구현은 각 클래스에 맡긴다
- 독수리의 '비행', 팽귄의 '수영'이 있으나 독수리에는 '수영'이 없고 팽귄에는 '비행'이 없으므로 이는 자식 클래스에서 선언한다

----이러면 아래와 같은 효과를 얻을 수 있는데
-독수리의 비행에 문제가 있다면 이건 독수리 클래스의 '비행' 메서드 문제임을 바로 알 수 있다. 팽귄의 수영 또한 마찬가지이다.
-팽귄은 정상적으로 만들어지는데 독수리는 머리가 두개가 되어 만들어진다면, 일반적으로 독수리 클래스가 문제가 있을 거라 생각하고
 독수리 클래스를 가지고 머리를 낑낑 싸맨 뒤에야 조류 클래스에 문제가 있는지 찾아보겠지만, SRP원칙에 따라 '머리'의 전권을
 조류 클래스가 쥐고 있음을 인지하고 있다면, 조류 클래스의 어떤 문제가 독수리의 머리를 두개로 만든다는걸 확인하고 바로 조치할 수
 있다.

 <오버라이딩과 S원칙> "오버라이딩을 최소화해야 한다"
 오버라이딩이 이루어지면 부모 클래스와 자식 클래스간의 책임소재가 불분명해진다.(같은 기능을 부모개체와 자식개체가 모두 책임진다.)
 따라서 한 기능의 '공통된 부분'과 '다른 부분'을 구분하여 책임소재를 명확히 해야 한다.
 다시 말해 오버라이딩되는 부분을 최소화하고, 자식 클래스간 오버라이딩된 부분끼리 중복이 발생한다면, 분리하여 부모 클래스에서 제어한다.
 -아메리카노와 라떼에서 커피 샷은 '커피' 부모 클래스에서 처리해야 한다.
 -아메리카노에는 물을 타고 라떼에는 우유를 타는 건 각 자식 클래스에서 부모 클래스를 확장하여 사용한다
 -이를 통일하기 위해 부모 클래스에 공통된 인터페이스를(굳이 인터페이스를 쓰지 않더라도) 선언할 수는 있고, 선언하는 게 좋다.



O : Open-Close Principle(개방 폐쇄 원칙)
모든 클래스는 확장에 있어 개방적이고 수정에 있어 폐쇄되어 있어야 한다.

<public vs Getter/Setter>
-클래스의 getter, setter를 통해 기능을 추가,변경하는 것은 자유로워야 한다.
-public변수는 확장에 대해 닫혀있다. 하지만 Getter/Setter는 오버라이딩/데코레이션을 통해 확장 가능하다.

<상속과 O원칙>
-클래스의 기능 추가/변경은 어느때나 상속 등을 통해 가능해야 한다.
-클래스의 본질 자체가 수정되어서는 안된다.
-클래스를 추가할 때, 기능을 확장할 수 있게 디자인하되, 클래스가 수행할 수 있는 일 자체가 바뀌어서는 안된다.

-Bow 클래스는 기능이 확장되어 Attack시 Arrow를 생성하여 발사한다.
--하지만 Bow 클래스가 Attack을 하지 못하거나, Attack의 공격이라는 본질이 바뀐 건 아니다.
--Attack에 힐링 효과가 들어간다면, 그때부터는 문제가 발생할 거다.
--(Attack의 기능은 '확장' 가능하지만 '수정' 가능하지 않다)



L : 리스코프 치환 법칙
이름은 어려운데(아마 SOLID를 정말로 맞추고 싶은가 봐요) 이건 '다형성'을 유지하는 것과 관련된 문제.
-자식 클래스는 부모 클래스가 들어가는 자리에 들어가도 아무런 문제가 없어야 한다.

-Weapon 자리에는 Sword, Spear, Bow, Gun, Cannon 등 어떤 자식 클래스가 들어오건 정상 작동하여야 한다.
-자식 클래스가 메서드를 오버라이딩하였어도 그 본질적인 의미가 달라져서는 안된다.
-Weapon.attack을 오버라이딩한 Sword.attack, Spear.attack, Bow.attack 등은 모두 Weapon.attack과 같은 역할, 즉 공격 역할을 해야 한다.
-이 함수가 공격이 아닌 부대의 공격 명령으로 바뀌어버렸다면, 문제가 발생할 수 있다.



I : Interface Separation Principle (인터페이스 분리의 원칙)
쓰지 않는 인터페이스는 들고 있지 않아야 한다.
-MapObject라는 클래스를 만들어 맵상에 새를 구현하려 한다. 이를 위해서 MapObject에 인터페이스 IMovable을 상속시켰다.
-맵에 있는 나무도 MapObject로 만들었지만 나무는 움직이지 않으니 IMovable 관련 메서드들은 아무 일도 안하게 하였다.

-이러면 이 클래스 외부에서는 나무도 움직일 수 있는 개체라 판단할 수 있다!
-MovableMapObject라는 MapObject의 상속개체를 만들고 거기에 IMovable을 부여하면 I원칙을 지킬 수 있다.




D : Dependency Inversion Principle(의존성 역전의 원칙)
다른 원칙과는 달리, 대놓고 위키피디아에도 말로 적혀있음. 모두 대문자인거 보니 매우 중요해보임.
하지만 토익 990이어도 뭔말인지 모를 영어
------------------------------------------------------------------------------------------------------
A. HIGH LEVEL MODULES SHOULD NOT DEPEND UPON LOW LEVEL MODULES. BOTH SHOULD DEPEND UPON ABSTRACTIONS.
B. ABSTRACTIONS SHOULD NOT DEPEND UPON DETAILS. DETAILS SHOULD DEPEND UPON ABSTRACTIONS
------------------------------------------------------------------------------------------------------
요약 : 상위 개체가 하위 개체에 의존성을 지녀서는 안된다. 모두 추상화된 기능에 의존해야 한다.

A. <저수준의 모듈에 고수준의 모듈이 의존해서는 안된다. 두 모듈은 추상화된 기능에 의존해야 한다.>
HIGH LEVEL MODULES SHOULD NOT DEPEND UPON LOW LEVEL MODULES. BOTH SHOULD DEPEND UPON ABSTRACTIONS.
- Weapon개체는 '공격할 수 있는 기구'이다. 이 기구가 내부적으로 어떤 일을 하는지에 상위 개체가 의존해서는 안된다.
--  Character개체는 Weapon이 공격할 수 있다는 것만 알고 있다. 이 Weapon이 총알을 생성해서 발사하는지, 근접에서 휘두르는지는 Character는 모른다.
--  Weapon 개체는 Character 개체가 자신의 Attack을 실행시킨다는 것만 안다. 언제, 어떤 명령 후에 실행시키는지는 모른다.
- 각 개체의 기능은 추상화되어서, Character가 Weapon을 '사용' 멍령을 내리면 'Weapon'이 '공격' 한다는 것만 보여야 한다.
- 두 개체는 서로의 디테일에 대해서는 알지 못하고, 알지 못한 채로도 정상동작해야 한다.

요약하면, Character는 추상화된 '공격'이라는 기능만을 사용해서 Weapon을 사용해야 하고,
Weapon은 Character가 자신에게 Weapon 명령을 언제 내리건 즉시 '공격' 기능을 사용할 수 있어야 한다.


B. <추상화된 관념은 디테일에 의존해서는 안된다.디테일한 개념이 추상화된 개념에 의존해야 한다.>
- 상위 모듈에서 하위 모듈의 추상화된 개념을 수행시킬 때, 해당 개념이 하위 개체의 디테일에 따라 다르게 처리되어서는 안된다.
- Gun은 Attack을 위해 많은 기능들(방아쇠가 당겨지고 공이로 총알 뒤를 쳐서 총알이 점화되어 총신을 지나 발사.....)을 수행해야 한다.
--  하지만 '공격'이라는 기능이 그 세부과정에 영향을 받아 구현이 달라져서는 안된다.
--  Gun은 오로지 Attack이라는 추상적인 관념을 수행하기 위한 세부사항을 시행할 뿐이며
    Attack이라는 결과는 내부에서 무슨 일이 일어나건 상관없이 진행되어야 한다.
--  다시 말해 총이 내부에서 뭘 하건, 방아쇠를 당기면 발사되어야 한다. 그게 이루어지지 않는다면 '총'이라 할 수 없다.

-D원칙은 인터페이스를 통해서 쉽게 구현된다.
--  Interface IAttackable을 상속받았다면 이 개체는 추상적인 기능 Attack을 구현할 것이다.
--  개체가 Attack을 어떻게 구현하건 Attack은 같은 기능을 할 거라고 기대할 수 있다.





정리하면
클래스는 어떤 물질의 '본질'이다. 따라서 어떤 클래스를 만들 때에는 '이 클래스가 무엇인가'에 대한 통찰이 필요하다.
(인스턴스는 그러한 '본질'이 구현된 존재이다.)
<S>
그러한 '본질'과 관련없는 모든 것들은 다른 클래스로 떨어뜨려야 한다.
<O>
이러한 '본질'에 기반한 다른 '본질'('커피'라는 본질에 기반한 '아메리카노')를 얻기 위해서 클래스는 확장에 대해 열려있어야 한다.
그러한 '본질'이 망가지지 않도록 클래스는 수정에 대해 닫혀있어야 한다.
<L>
하위적인 '본질'은 그 '근원'이 아닌 다른 존재가 되어서는 안된다. 그를 검사하는 가장 간단한 방법은 근원의 자리에 하위 '본질'을 놓는 것이다.
(커피는 '음료'의 하위 개념이다. 따라서 음료의 '마신다'라는 동작은 커피를 '마신다'라고 해도 문제 없이 적용된다.)
(오렌지 주스는 '커피'의 하위 개념이 아니다. 따라서 커피의 '카페인 함량' 성질은 오렌지 주스에는 없다.)
<I>
'본질'이 아닌 다른 기능은 존재하지 않아야 한다(S원칙). 그 기능이 아무런 일을 하지 않도록 조치되었어도.
('전기 자동차'라는 본질에 연료통은 필요하지 않다. 동작 계통에 연결되지 않아 아무런 역할을 하지 않더라도, 연료통은 전기자동차에는 없어야 한다.)
<D>
모든 건 '본질'에 의지해야 한다. '본질'을 만들어내는 디테일한 부분은 감추어져 있어 바깥과 관련을 가져서는 안된다.
